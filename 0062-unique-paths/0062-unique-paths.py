'''
조건 : 로봇은 오른쪽 또는 아래로만 이동 가능
경로 수 = 위쪽에서 내려온 경로 + 왼쪽에서 온 경로
dp[j] = 현재 행의 j열까지 도달하는 경로 수

시간 복잡도: O(m×n)
    모든 셀을 한 번씩 계산하므로
공간 복잡도: O(n) 
    1차원 배열만 사용므로
'''

class Solution:
    def uniquePaths(self, m: int, n: int):
        dp = [1] * n  # 첫 번째 행은 모든 열에 도달하는 경로가 1개(오른쪽으로만 이동하므로)
        
        for i in range(1, m):      # 2번째 행부터 마지막 행까지 순회
            for j in range(1, n):  # 2번째 열부터 마지막 열까지 순회
                dp[j] += dp[j-1]   # 왼쪽 셀값(왼쪽방향 경로) + 현재 값(위쪽 방향 경로)
        
        return dp[-1]  # 마지막 셀 값이 총 경로 수