'''
문제의 의도:
이 문제는 32비트 부호 없는 정수의 비트를 뒤집는 문제임. 
즉, 이진수 표현에서 첫 번째 비트와 마지막 비트를 바꾸고, 
두 번째 비트와 31번째 비트를 바꾸는 식으로 모든 비트의 순서를 뒤집어야 함.

해결 방법:
비트 조작(Bit Manipulation)을 사용함
원본 숫자의 비트를 오른쪽부터 하나씩 추출
결과 숫자에 왼쪽부터 하나씩 추가
이렇게 하면 자연스럽게 비트 순서가 뒤집어짐
마치 숫자를 한 자리씩 읽어서 거꾸로 쓰는 것과 같은 원리임
32번 반복하여 모든 비트를 뒤집기

Example 1.의 경우
Input: n = 43261596 (이진수: 00000010100101000001111010011100)

1번째: n의 마지막 비트 0 추출
- result = 0 << 1 = 0, result |= 0 = 0
- n = n >> 1 = 0000001010010100000111101001110

2번째: n의 마지막 비트 0 추출  
- result = 0 << 1 = 0, result |= 0 = 0
- n = n >> 1 = 000000101001010000011110100111

3번째: n의 마지막 비트 1 추출
- result = 0 << 1 = 0, result |= 1 = 1
- n = n >> 1 = 00000010100101000001111010011

... (32번 반복)

최종: result = 00111001011110000010100101000000
Output: 964176192

시간 복잡도: O(1)
항상 정확히 32번의 반복을 수행
입력 크기에 관계없이 상수 시간

공간 복잡도: O(1)
몇 개의 변수만 사용하므로 상수 공간
추가 배열이나 자료구조 사용하지 않음

'''
class Solution:
    def reverseBits(self, n: int) -> int:
        # 뒤집힌 비트들을 저장할 결과 변수를 0으로 초기화
        result = 0
        
        # 32비트를 모두 처리하기 위해 32번 반복
        for i in range(32):
            # 결과를 왼쪽으로 1비트 시프트하여 새로운 비트를 위한 공간 확보
            # 예: 101 -> 1010(오른쪽에 0이 추가됨)
            result <<= 1
            
            # n & 1: n의 가장 오른쪽 비트를 추출 (0 또는 1)
            # result |= ...: 추출한 비트를 result의 가장 오른쪽에 추가
            # OR 연산으로 비트를 설정
            result |= n & 1
            
            # n을 오른쪽으로 1비트 시프트하여 다음 비트를 처리할 준비
            # 예: 1101 → 110 (가장 오른쪽 비트가 제거됨)
            n >>= 1
        
        return result
